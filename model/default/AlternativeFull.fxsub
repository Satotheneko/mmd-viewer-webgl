// AlternativeFull
// VS、PS共に3.0以上が必要です。(セルフシャドウなしでも)

float4 EgColor; 
float4 SpcColor;

// パラメータ宣言
#define SOFTSHADOW_RESOLUTION 4096

float Script : STANDARDSGLOBAL <
	string ScriptOutput = "color";
	string ScriptClass = "sceneorobject";
	string ScriptOrder = "standard";
> = 0.8;

// 座法変換行列
float4x4 WorldViewProjMatrix	  : WORLDVIEWPROJECTION;
float4x4 WorldMatrix			  : WORLD;
float4x4 ViewMatrix			   : VIEW;

#ifndef USE_ABSOLUTE_SHADOW_SYSTEM
float4x4 LightWorldViewProjMatrix : WORLDVIEWPROJECTION < string Object = "Light"; >;

float3   LightDirection	: DIRECTION < string Object = "Light"; >;
#endif
float3   CameraPosition	: POSITION  < string Object = "Camera"; >;

// マテリアル色
float4   MaterialDiffuse   : DIFFUSE  < string Object = "Geometry"; >;
float3   MaterialAmbient   : AMBIENT  < string Object = "Geometry"; >;
float3   MaterialEmmisive  : EMISSIVE < string Object = "Geometry"; >;
float3   MaterialSpecular  : SPECULAR < string Object = "Geometry"; >;
float	SpecularPower	 : SPECULARPOWER < string Object = "Geometry"; >;
float3   MaterialToon	  : TOONCOLOR;
float4   EdgeColor		 : EDGECOLOR;
// ライト色
float3   LightDiffuse	  : DIFFUSE   < string Object = "Light"; >;
float3   LightAmbient	  : AMBIENT   < string Object = "Light"; >;
float3   LightSpecular	 : SPECULAR  < string Object = "Light"; >;
static float4 DiffuseColor  = MaterialDiffuse  * float4(LightDiffuse, 1.0f);
static float3 AmbientColor  = saturate(MaterialAmbient  * LightAmbient + MaterialEmmisive);
static float3 SpecularColor = MaterialSpecular * LightSpecular;

bool	 parthf;   // パースペクティブフラグ
bool	 transp;   // 半透明フラグ
bool	 spadd;	// スフィアマップ加算合成フラグ
#define SKII1	1500
#define SKII2	8000
#define Toon	 3

// シェーディングのヒント用テクスチャ
texture2D ThresholdTexture : TEXTURE <
	string ResourceName = TEXTURE_THRESHOLD;
>;
sampler2D ThresholdTextureSampler = sampler_state {
	texture = <ThresholdTexture>;
	AddressU = CLAMP;
	AddressV = CLAMP;
	MINFILTER = NONE;
	MAGFILTER = NONE;
	MIPFILTER = NONE;
};

#ifdef USE_HIGHLIGHT_TEXTURE
texture2D HighlightTexture : TEXTURE <
	string ResourceName = TEXTURE_HIGHLIGHT;
>;
sampler2D HighlightTextureSampler = sampler_state {
	texture = <HighlightTexture>;
	MINFILTER = ANISOTROPIC;
	MAGFILTER = ANISOTROPIC;
	MIPFILTER = NONE;
	MAXANISOTROPY = MAX_ANISOTROPY;
};
#endif

// 影用テクスチャ
#ifndef USE_MATERIAL_TEXTURE
texture2D ShadowTexture : TEXTURE <
	string ResourceName = TEXTURE_SHADOW;
>;
sampler2D ShadowTextureSampler = sampler_state {
	texture = <ShadowTexture>;
	MINFILTER = ANISOTROPIC;
	MAGFILTER = ANISOTROPIC;
	MIPFILTER = NONE;
	MAXANISOTROPY = MAX_ANISOTROPY;
};
#else
texture2D ShadowTexture : MATERIALTEXTURE;
#endif

// オブジェクトのテクスチャ
#ifdef USE_MIPMAP
texture2D ObjectTexture: MATERIALTEXTURE<
	string Format = "A8R8G8B8" ;
>;
sampler2D DefObjTexSampler = sampler_state {
    texture = <ObjectTexture>;
    MINFILTER = LINEAR;
    MAGFILTER = LINEAR;
};

texture2D UseMipmapObjectTexture : RENDERCOLORTARGET <
	int MipLevels = 0;
	string Format = "A8R8G8B8" ;
>;
sampler2D ObjTexSampler = sampler_state {
	texture = <UseMipmapObjectTexture>;
	MINFILTER = ANISOTROPIC;
	MAGFILTER = ANISOTROPIC;
	MIPFILTER = LINEAR;
	MAXANISOTROPY = FX_MAX_ANISOTROPY;
};
#else
texture2D ObjectTexture: MATERIALTEXTURE;
sampler2D ObjTexSampler = sampler_state {
	texture = <ObjectTexture>;
	MINFILTER = LINEAR;
	MAGFILTER = LINEAR;
	MIPFILTER = LINEAR;
};
#endif

texture2D DepthBuffer : RenderDepthStencilTarget <
	string Format = "D24S8";
>;

#ifdef USE_MATERIAL_SPHERE
// スフィアマップのテクスチャ
texture2D ObjectSphereMap: MATERIALSPHEREMAP;
sampler2D ObjSphareSampler = sampler_state {
	texture = <ObjectSphereMap>;
	MINFILTER = LINEAR;
	MAGFILTER = LINEAR;
	MIPFILTER = LINEAR;
};
#endif

#ifdef USE_NORMALMAP
// ノーマルマップのテクスチャ
texture2D NormalMap <
	string ResourceName = TEXTURE_NORMALMAP;
	int MipLevels = 0;
>;
sampler2D NormalMapSamp = sampler_state {
	texture = <NormalMap>;
	MINFILTER = ANISOTROPIC;
	MAGFILTER = ANISOTROPIC;
	MIPFILTER = ANISOTROPIC;
	MAXANISOTROPY = MAX_ANISOTROPY;
	AddressU  = WRAP;
	AddressV = WRAP;
};
#endif

#ifdef TEXTURE_EDGE
// エッジのテクスチャ
texture2D EdgeTexture <
	string ResourceName = TEXTURE_EDGE;
>;
sampler2D EdgeSampler = sampler_state {
    texture = <EdgeTexture>;
	MINFILTER = ANISOTROPIC;
	MAGFILTER = ANISOTROPIC;
	MIPFILTER = ANISOTROPIC;
	MAXANISOTROPY = MAX_ANISOTROPY;
};
#endif

#ifdef TEXTURE_EDGE_SCALE
// エッジ太さのテクスチャ
texture2D EdgeScaleTexture <
	string ResourceName = TEXTURE_EDGE_SCALE;
>;
sampler2D EdgeScaleSampler = sampler_state {
    texture = <EdgeScaleTexture>;
	MINFILTER = ANISOTROPIC;
	MAGFILTER = ANISOTROPIC;
	MIPFILTER = ANISOTROPIC;
	MAXANISOTROPY = MAX_ANISOTROPY;
};
#endif

#ifdef USE_ABSOLUTE_SHADOW_SYSTEM
// AbsoluteShadowシステム　ここから↓

float X_SHADOWPOWER = 1.0;
float PMD_SHADOWPOWER = 0.0;

#include "AbsoluteShadowShaderSystem.fx"

static float3 LightDirection = LightDirVec;

// AbsoluteShadowシステム　ここまで↑
#endif

#ifdef USE_EXCELLENT_SHADOW_SYSTEM
float X_SHADOWPOWER = 1.0;   //アクセサリ影濃さ
float PMD_SHADOWPOWER = 0.2; //モデル影濃さ


//スクリーンシャドウマップ取得
shared texture2D ScreenShadowMapProcessed : RENDERCOLORTARGET <
	float2 ViewPortRatio = {1.0,1.0};
	int MipLevels = 1;
	string Format = "D3DFMT_R16F";
>;
sampler2D ScreenShadowMapProcessedSamp = sampler_state {
	texture = <ScreenShadowMapProcessed>;
	MinFilter = LINEAR;
	MagFilter = LINEAR;
	MipFilter = LINEAR;
	AddressU  = CLAMP;
	AddressV = CLAMP;
};

//SSAOマップ取得
shared texture2D ExShadowSSAOMapOut : RENDERCOLORTARGET <
	float2 ViewPortRatio = {1.0,1.0};
	int MipLevels = 1;
	string Format = "R16F";
>;

sampler2D ExShadowSSAOMapSamp = sampler_state {
	texture = <ExShadowSSAOMapOut>;
	MinFilter = LINEAR;
	MagFilter = LINEAR;
	MipFilter = NONE;
	AddressU  = CLAMP;
	AddressV = CLAMP;
};

// スクリーンサイズ
float2 ES_ViewportSize : VIEWPORTPIXELSIZE;
static float2 ES_ViewportOffset = (float2(0.5,0.5)/ES_ViewportSize);

bool Exist_ExcellentShadow : CONTROLOBJECT < string name = "ExcellentShadow.x"; >;
bool Exist_ExShadowSSAO : CONTROLOBJECT < string name = "ExShadowSSAO.x"; >;

float ShadowRate : CONTROLOBJECT < string name = "ExcellentShadow.x"; string item = "Tr"; >;


float3   ES_CameraPos1	  : POSITION  < string Object = "Camera"; >;

float es_size0 : CONTROLOBJECT < string name = "ExcellentShadow.x"; string item = "Si"; >;
float4x4 es_mat1 : CONTROLOBJECT < string name = "ExcellentShadow.x"; >;
static float3 es_move1 = float3(es_mat1._41, es_mat1._42, es_mat1._43 );

//カメラとシャドウ中心の距離
static float CameraDistance1 = length(ES_CameraPos1 - es_move1);
#endif

// スクリーンサイズ
float2 ViewportSize : VIEWPORTPIXELSIZE;
static float2 ViewportOffset = (float2(0.5,0.5)/ViewportSize);

// レンダリングターゲットのクリア値
float4 ClearColor = {0,0,0,0};
float ClearDepth  = 1.0;

#ifdef USE_BEVEL
float2 test[]=
{
	{1,0},	{0,1},
	{-1,0},	{0,-1},
	{1,-1},	{-1,1},
	{1,1},	{-1,-1},
};
static float2 SampStep = (BevelParam/ViewportSize);
#endif
// MMD本来のsamplerを上書きしないための記述です。削除不可。
/*
sampler MMDSamp0 : register(s0);
sampler MMDSamp1 : register(s1);
sampler MMDSamp2 : register(s2);
*/
#ifdef USE_NORMALMAP
///////////////////////////////////////////////////////////////////////////////////////////////
// 法線計算関数

float3x3 compute_tangent_frame(float3 Normal, float3 View, float2 UV)
{
  float3 dp1 = ddx(View);
  float3 dp2 = ddy(View);
  float2 duv1 = ddx(UV);
  float2 duv2 = ddy(UV);

  float3x3 M = float3x3(dp1, dp2, cross(dp1, dp2));
  float2x3 inverseM = float2x3(cross(M[1], M[2]), cross(M[2], M[0]));
  float3 Tangent = mul(float2(duv1.x, duv2.x), inverseM);
  float3 Binormal = mul(float2(duv1.y, duv2.y), inverseM);

  return float3x3(normalize(Tangent), normalize(Binormal), Normal);
}
#endif

//べックマン分布計算関数
inline float CalcBeckman(float m, float cosbeta)
{
	return (
		exp(-(1-(cosbeta*cosbeta))/(m*m*cosbeta*cosbeta))
		/(4*m*m*cosbeta*cosbeta*cosbeta*cosbeta)
		);
}

//フレネル計算関数
inline float CalcFresnel(float n, float c)
{
	float g = sqrt(n*n + c*c - 1);
	float T1 = ((g-c)*(g-c))/((g+c)*(g+c));
	float T2 = 1 + ( (c*(g+c)-1)*(c*(g+c)-1) )/( (c*(g-c)+1)*(c*(g-c)+1) );
	return 0.5 * T1 * T2;
}

//スペキュラ計算関数
inline float3 CalcSpecular(float3 L, float3 N, float3 V, float3 Col)
{
	float3 H = normalize(L + V);	//ハーフベクトル

	//計算に使う角度
	float NV = dot(N, V);
	float NH = dot(N, H);
	float VH = dot(V, H);
	float NL = dot(N, L);

	//Beckmann分布関数
	float D = CalcBeckman(0.35f, NH);

	//幾何減衰率
	float G = min(1, min(2*NH*NV/VH, 2*NH*NL/VH));

	//フレネル項
	float F = CalcFresnel(20.0f, dot(L, H));
	
	return max(0, F*D*G/NV)*1 * Col;
}

#ifdef USE_MIPMAP
////////////////////////////////////////////////////////////////////////////////////////////////
// ミップマップ作成

struct VS_OUTPUT_MIPMAPCREATER {
    float4 Pos	: POSITION;
    float2 Tex	: TEXCOORD0;
};
VS_OUTPUT_MIPMAPCREATER VS_MipMapCreater( float4 Pos : POSITION, float4 Tex : TEXCOORD0 ){
    VS_OUTPUT_MIPMAPCREATER Out;
    Out.Pos = Pos;
    Out.Tex = Tex;
    Out.Tex += ViewportOffset;
    return Out;
}

float4  PS_MipMapCreater(float2 Tex: TEXCOORD0) : COLOR0
{
	return tex2D(DefObjTexSampler,Tex);
}
#endif

////////////////////////////////////////////////////////////////////////////////////////////////
// 輪郭描画

// 頂点シェーダ
float4 ColorRender_VS(float4 Pos : POSITION, float3 Normal : NORMAL) : POSITION 
{
	return mul( Pos, WorldViewProjMatrix );
}

// ピクセルシェーダ
float4 ColorRender_PS() : COLOR
{
	// 輪郭色で塗りつぶし
	return EdgeColor;
}

// 輪郭描画用テクニック
technique EdgeTec < string MMDPass = "edge"; > {
#ifndef USE_EDGE_TWEAK
	pass DrawEdge {
		AlphaBlendEnable = FALSE;
		AlphaTestEnable  = FALSE;

		VertexShader = compile vs_2_0 ColorRender_VS();
		PixelShader  = compile ps_2_0 ColorRender_PS();
	}
#endif
}

///////////////////////////////////////////////////////////////////////////////////////////////
// 影（非セルフシャドウ）描画
// 頂点シェーダ
float4 Shadow_VS(float4 Pos : POSITION) : POSITION
{
	// カメラ視点のワールドビュー射影変換
	return mul( Pos, WorldViewProjMatrix );
}

// ピクセルシェーダ
float4 Shadow_PS() : COLOR
{
	// アンビエント色で塗りつぶし
    return float4(EgColor.rgb, 0.65f);
}

// 影描画用テクニック
technique ShadowTec < string MMDPass = "shadow"; > {
	pass DrawShadow {
		VertexShader = compile vs_2_0 Shadow_VS();
		PixelShader  = compile ps_2_0 Shadow_PS();
	}
}

#ifdef USE_NONE_SELFSHADOW_MODE
///////////////////////////////////////////////////////////////////////////////////////////////
// オブジェクト描画（セルフシャドウOFF）
struct VS_OUTPUT {
	float4 Pos		: POSITION;	// 射影変換座標
	float2 Tex		: TEXCOORD1;   // テクスチャ
	float3 Normal	: TEXCOORD2;   // 法線
	float3 Eye		: TEXCOORD3;   // カメラとの相対位置
	float2 SpTex	: TEXCOORD4;	 // スフィアマップテクスチャ座標
	float4 Color	: COLOR0;	  // ディフューズ色
};

// 頂点シェーダ
VS_OUTPUT Basic_VS(float4 Pos : POSITION, float3 Normal : NORMAL, float2 Tex : TEXCOORD0, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon)
{
	VS_OUTPUT Out = (VS_OUTPUT)0;

	// カメラ視点のワールドビュー射影変換
	Out.Pos = mul( Pos, WorldViewProjMatrix );

	// カメラとの相対位置
	Out.Eye = CameraPosition - mul( Pos, WorldMatrix );
	// 頂点法線
	Out.Normal = normalize( mul( Normal, (float3x3)WorldMatrix ) );

	// ディフューズ色＋アンビエント色 計算
    Out.Color.rgb = EgColor.rgb;
	if ( !useToon ) {
		Out.Color.rgb += max(0,dot( Out.Normal, -LightDirection )) * AmbientColor;
	}
    Out.Color.a = EgColor.a;
	Out.Color = saturate( Out.Color );

	// テクスチャ座標
	Out.Tex = Tex;

#ifdef USE_MATERIAL_SPHERE
	if ( useSphereMap ) {
		// スフィアマップテクスチャ座標
		float2 NormalWV = mul( Out.Normal, (float3x3)ViewMatrix );
		Out.SpTex.x = NormalWV.x * 0.5f + 0.5f;
		Out.SpTex.y = NormalWV.y * -0.5f + 0.5f;
	}
#endif

	return Out;
}

// ピクセルシェーダ
float4 _NoSsShaderMain(VS_OUTPUT IN,bool useTexture,bool useSphereMap,bool useToon)
{
	float3 N = normalize(IN.Normal);
	float3 V = normalize(IN.Eye);

#ifdef USE_NORMALMAP
	// ------------------------------------------------------------
	//法線マップ処理
	// ------------------------------------------------------------
	float4 NormalColor = tex2D( NormalMapSamp, IN.Tex * NormalMapResolution) * 2;
	NormalColor = NormalColor.rgba;
	NormalColor.a = 1;
	float3x3 tangentFrame = compute_tangent_frame(N, V, IN.Tex);
	N = normalize(mul(NormalColor - 1.0f, tangentFrame));
#endif
	// ------------------------------------------------------------
	// シェーディング計算
	// ------------------------------------------------------------
	float d;
//#ifdef USE_ABSOLUTE_SHADOW_SYSTEM
//	d = saturate(dot(normalize(IN.Normal),-normalize(-Rot._21_22_23)));
//#else
	d = saturate(dot(N,-LightDirection));
//#endif

	// ------------------------------------------------------------
	// フィルライト計算
	// ------------------------------------------------------------
#ifdef USE_FILL_LIGHT_TYPE1
	d += max(0, dot(N, V) * FillLight1Power);
#endif
#ifdef USE_FILL_LIGHT_TYPE2
	d += max(0, dot(normalize(IN.Normal * float3(-1,-1,1)), -LightDirection) * FillLight2Power);
#endif

	// ------------------------------------------------------------
	// リムライト計算
	// ------------------------------------------------------------
#ifdef USE_RIM_LIGHT
	float3 RimColor = (1 - max(0, pow(dot( IN.Normal, V), 2))) * RimLightPower;
	RimColor = pow(RimColor, RimLightThreshold);
	// リムライト適用
	d += RimColor.r;
#endif

	// ------------------------------------------------------------
	// ランバート計算
	// ------------------------------------------------------------
#ifdef USE_LAMBERT
	d = pow(d * LambertFactor + (1 - LambertFactor), 2);
#endif

	// ------------------------------------------------------------
	// 陰影の計算
	// ------------------------------------------------------------
	float4 Color = IN.Color;
	float4 ShadowColor = float4(EgColor.rgb, Color.a);  // 影の色

	if ( useTexture ) {
		// テクスチャ適用
		float4 TexColor = tex2D( ObjTexSampler, IN.Tex );
#ifdef USE_MATERIAL_TEXTURE
		ShadowColor *= TexColor;
#else
		// シャドウテクスチャ適用
		ShadowColor *= tex2D( ShadowTextureSampler, IN.Tex );
#endif
		Color *= TexColor;
	}

#ifdef USE_MATERIAL_TEXTURE
	// トゥーンテクスチャ適用
	if (useToon) {
#ifdef USE_MATERIAL_TEXTURE
		ShadowColor.rgb *= MaterialToon * DefaultModeShadowColor;
#else
		ShadowColor.rgb *= MaterialToon;
#endif
	}
#endif

#ifdef USE_SHADOWCOLOR_SELFPOWER_MODE
	// 材質の自己乗算で影色を傾向付ける
	float3 tmpColor = saturate(Color.rgb - 0.01); // 1.0対策
#ifdef SELFPOWER_MODE_IGNORE_SHADOWLEVEL
	ShadowColor.rgb = pow(tmpColor, SelfPowerShadowStrength);
#else
	ShadowColor.rgb *= pow(tmpColor, SelfPowerShadowStrength);
#endif
#endif
#ifdef USE_MATERIAL_SPECULAR
	// スペキュラ色計算
	float3 HalfVector = normalize( V + -LightDirection );
	#ifdef USE_EXSPECULAR
    float3 Specular = CalcSpecular(normalize(-LightDirection), N, V, EgColor)  * LightAmbient;
		#ifdef USE_FILL_LIGHT_TYPE1
    Specular += CalcSpecular(V, N, V, EgColor * FillLight1Power) * LightAmbient;
		#endif
		#ifdef USE_FILL_LIGHT_TYPE2
    Specular += CalcSpecular(normalize(-LightDirection * float3(-1,-1,1)), N, V, EgColor * FillLight2Power) * LightAmbient;
		#endif
		#ifdef USE_RIM_LIGHT
    Specular += CalcSpecular(1 - V, N, V, EgColor * RimLightPower) * LightAmbient;
		#endif
	Specular *= 0.1;
	#else
	float3 Specular = pow( max(0,dot( HalfVector, N )), SpcColor.a ) * SpcColor.rgb;
	#endif

	#ifdef USE_SPECULAR_CHEET
		Specular *= SpecularBoost;
	#endif
	Color.rgb += Specular;
	ShadowColor.rgb += Specular;
	d += max(max(Specular.r, Specular.g), Specular.b);
#endif

	// ------------------------------------------------------------
	// スフィアマップ適用
	// ------------------------------------------------------------
#ifdef USE_MATERIAL_SPHERE
	if ( useSphereMap ) {
		float4 TexColor = tex2D(ObjSphareSampler,IN.SpTex);
	#ifdef USE_SPHERE_CHEET
		TexColor *= SphereBoost;
	#endif
		if(spadd) {
			Color.rgb += TexColor.rgb;
			ShadowColor.rgb += TexColor.rgb;
			d += max(max(TexColor.r, TexColor.g),TexColor.b);
		} else {
			Color.rgb *= TexColor.rgb;
			ShadowColor.rgb *= TexColor.rgb;
			d *= max(max(TexColor.r, TexColor.g),TexColor.b);
		}
	}
#endif

	// ------------------------------------------------------------
	// シェードマップの適用
	// ------------------------------------------------------------
	float4 Threshold = tex2D( ThresholdTextureSampler, float2(saturate(d), 0));

	// ------------------------------------------------------------
	// シェードマップのα値で明るさ強調
	// ------------------------------------------------------------
#ifdef USE_HIGHLIGHT_TEXTURE
	float4 HighlightColor = tex2D(HighlightTextureSampler, IN.Tex);
	Color.rgb = lerp(HighlightColor.rgb, Color.rgb, saturate(Threshold.a));
	#ifdef USE_HIGHLIGHT_CHEET
	Color.rgb = lerp(HighlightColor.rgb * (1 + pow((1 - Threshold.a), 1 / HighlightPower)), Color.rgb, Threshold.a);
	#endif
#else
	#ifdef USE_HIGHLIGHT_CHEET
	float3 HighlightColor = (1 + pow((1 - Threshold.a), 1 / HighlightPower));
	Color.rgb = lerp(Color.rgb * HighlightColor, Color.rgb, Threshold.a);
	#endif
#endif

	// ------------------------------------------------------------
	// 明暗のブレンド
	// ------------------------------------------------------------
	Color.rgb = lerp(ShadowColor.rgb, Color.rgb, Threshold);

	return Color;
}

float4 Basic_PS(VS_OUTPUT IN, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon) : COLOR0
{
	float4 Color = _NoSsShaderMain(IN, useTexture, useSphereMap, useToon);

#ifdef HIGHLIGHT_ANTI_AUTOLUMINOUS
	return saturate(Color);
#else
	return Color;
#endif
}

#ifdef USE_EDGE_TWEAK
// 頂点シェーダ
VS_OUTPUT BasicEdge_VS(float4 Pos : POSITION, float3 Normal : NORMAL, float2 Tex : TEXCOORD0, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon)
{
	VS_OUTPUT Out = (VS_OUTPUT)0;

	// カメラとの相対位置
	Out.Eye = CameraPosition - mul( Pos, WorldMatrix );

	// カメラ視点のワールドビュー射影変換
	Out.Pos = mul( Pos, WorldViewProjMatrix );

	// 頂点法線
	Out.Normal = normalize( mul( Normal, (float3x3)WorldMatrix ) );

	// 法線方向にちょっとだけ膨らます
	#ifdef TEXTURE_EDGE_SCALE
	EdgeTickness *= 1 + tex2Dlod(EdgeScaleSampler, float4(Tex, 0, 0)).r * EdgeScale;
	#endif
	float4 tmpNormal = mul(Normal, WorldViewProjMatrix);
	tmpNormal.zw = 0;
	tmpNormal = normalize(tmpNormal) * EdgeTickness;
	Out.Pos.xy += tmpNormal * Out.Pos.w;

	// ディフューズ色＋アンビエント色 計算
	Out.Color.rgb = EgColor.rgb;
	if ( !useToon ) {
		Out.Color.rgb += max(0,dot( Out.Normal, -LightDirection )) * DiffuseColor.rgb;
	}
	Out.Color.a = EgColor.a;
	Out.Color = saturate( Out.Color );

	// テクスチャ座標
	Out.Tex = Tex;

#ifdef USE_MATERIAL_SPHERE
	if ( useSphereMap ) {
		// スフィアマップテクスチャ座標
		float2 NormalWV = mul( Out.Normal, (float3x3)ViewMatrix );
		Out.SpTex.x = NormalWV.x * 0.5f + 0.5f;
		Out.SpTex.y = NormalWV.y * -0.5f + 0.5f;
	}
#endif

	return Out;
}

float4 BasicEdge_PS(VS_OUTPUT IN, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon) : COLOR0
{
	#ifdef TEXTURE_EDGE
	float4 Color = tex2D(EdgeSampler, IN.Tex);
	#else
	float4 Color = saturate(_NoSsShaderMain(IN, useTexture, useSphereMap, useToon));
	Color.rgb = pow(Color.rgb, EdgePower) * EdgeDarkness;
	#endif
	return Color;
}
#endif

// オブジェクト描画用テクニック（アクセサリ用）
technique MainTec0 < string MMDPass = "object"; bool UseTexture = false; bool UseSphereMap = false; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(false, false, false);
        PixelShader  = compile ps_3_0 Basic_PS(false, false, false);
    }
#ifdef USE_EDGE_TWEAK
    pass DrawEdge {
		CULLMODE = CW;
        VertexShader = compile vs_3_0 BasicEdge_VS(false, false, false);
        PixelShader  = compile ps_3_0 BasicEdge_PS(false, false, false);
    }
#endif
}

technique MainTec1 < string MMDPass = "object"; bool UseTexture = true; bool UseSphereMap = false; bool UseToon = false;
#ifdef USE_MIPMAP
	string Script= 
		"RenderColorTarget0=UseMipmapObjectTexture;"
			"RenderDepthStencilTarget=DepthBuffer;"
				"ClearSetColor=ClearColor;"
				"ClearSetDepth=ClearDepth;"
				"Clear=Color;"
				"Clear=Depth;"
			"Pass=CreateMipmap;"
	#ifdef USE_EDGE_TWEAK
		"RenderColorTarget0=;"
			"RenderDepthStencilTarget=;"
			"Pass=DrawEdge;"
	#endif
		;
#endif
 > {
#ifdef USE_MIPMAP
	pass CreateMipmap < string Script= "Draw=Buffer;"; > {
		AlphaBlendEnable = FALSE;
		ZEnable = FALSE;
		VertexShader = compile vs_3_0 VS_MipMapCreater();
		PixelShader  = compile ps_3_0 PS_MipMapCreater();
	}
#endif
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(true, false, false);
        PixelShader  = compile ps_3_0 Basic_PS(true, false, false);
    }
#ifdef USE_EDGE_TWEAK
    pass DrawEdge {
		CULLMODE = CW;
        VertexShader = compile vs_3_0 BasicEdge_VS(true, false, false);
        PixelShader  = compile ps_3_0 BasicEdge_PS(true, false, false);
    }
#endif
}

technique MainTec2 < string MMDPass = "object"; bool UseTexture = false; bool UseSphereMap = true; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(false, true, false);
        PixelShader  = compile ps_3_0 Basic_PS(false, true, false);
    }
#ifdef USE_EDGE_TWEAK
    pass DrawEdge {
		CULLMODE = CW;
        VertexShader = compile vs_3_0 BasicEdge_VS(false, true, false);
        PixelShader  = compile ps_3_0 BasicEdge_PS(false, true, false);
    }
#endif
}

technique MainTec3 < string MMDPass = "object"; bool UseTexture = true; bool UseSphereMap = true; bool UseToon = false;
#ifdef USE_MIPMAP
	string Script= 
		"RenderColorTarget0=UseMipmapObjectTexture;"
			"RenderDepthStencilTarget=DepthBuffer;"
				"ClearSetColor=ClearColor;"
				"ClearSetDepth=ClearDepth;"
				"Clear=Color;"
				"Clear=Depth;"
			"Pass=CreateMipmap;"
	#ifdef USE_EDGE_TWEAK
		"RenderColorTarget0=;"
			"RenderDepthStencilTarget=;"
			"Pass=DrawEdge;"
	#endif
		;
#endif
 > {
#ifdef USE_MIPMAP
	pass CreateMipmap < string Script= "Draw=Buffer;"; > {
		AlphaBlendEnable = FALSE;
		ZEnable = FALSE;
		VertexShader = compile vs_3_0 VS_MipMapCreater();
		PixelShader  = compile ps_3_0 PS_MipMapCreater();
	}
#endif
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(true, true, false);
        PixelShader  = compile ps_3_0 Basic_PS(true, true, false);
    }
#ifdef USE_EDGE_TWEAK
    pass DrawEdge {
		CULLMODE = CW;
        VertexShader = compile vs_3_0 BasicEdge_VS(true, true, false);
        PixelShader  = compile ps_3_0 BasicEdge_PS(true, true, false);
    }
#endif
}

// オブジェクト描画用テクニック（PMDモデル用）
technique MainTec4 < string MMDPass = "object"; bool UseTexture = false; bool UseSphereMap = false; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(false, false, true);
        PixelShader  = compile ps_3_0 Basic_PS(false, false, true);
    }
#ifdef USE_EDGE_TWEAK
    pass DrawEdge {
		CULLMODE = CW;
        VertexShader = compile vs_3_0 BasicEdge_VS(false, false, true);
        PixelShader  = compile ps_3_0 BasicEdge_PS(false, false, true);
    }
#endif
}

technique MainTec5 < string MMDPass = "object"; bool UseTexture = true; bool UseSphereMap = false; bool UseToon = true; 
#ifdef USE_MIPMAP
	string Script= 
		"RenderColorTarget0=UseMipmapObjectTexture;"
			"RenderDepthStencilTarget=DepthBuffer;"
				"ClearSetColor=ClearColor;"
				"ClearSetDepth=ClearDepth;"
				"Clear=Color;"
				"Clear=Depth;"
			"Pass=CreateMipmap;"
	#ifdef USE_EDGE_TWEAK
		"RenderColorTarget0=;"
			"RenderDepthStencilTarget=;"
			"Pass=DrawEdge;"
	#endif
		;
#endif
 > {
#ifdef USE_MIPMAP
	pass CreateMipmap < string Script= "Draw=Buffer;"; > {
		AlphaBlendEnable = FALSE;
		ZEnable = FALSE;
		VertexShader = compile vs_3_0 VS_MipMapCreater();
		PixelShader  = compile ps_3_0 PS_MipMapCreater();
	}
#endif
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(true, false, true);
        PixelShader  = compile ps_3_0 Basic_PS(true, false, true);
    }
#ifdef USE_EDGE_TWEAK
    pass DrawEdge {
		CULLMODE = CW;
        VertexShader = compile vs_3_0 BasicEdge_VS(true, false, true);
        PixelShader  = compile ps_3_0 BasicEdge_PS(true, false, true);
    }
#endif
}

technique MainTec6 < string MMDPass = "object"; bool UseTexture = false; bool UseSphereMap = true; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(false, true, true);
        PixelShader  = compile ps_3_0 Basic_PS(false, true, true);
    }
#ifdef USE_EDGE_TWEAK
    pass DrawEdge {
		CULLMODE = CW;
        VertexShader = compile vs_3_0 BasicEdge_VS(false, true, true);
        PixelShader  = compile ps_3_0 BasicEdge_PS(false, true, true);
    }
#endif
}

technique MainTec7 < string MMDPass = "object"; bool UseTexture = true; bool UseSphereMap = true; bool UseToon = true; 
#ifdef USE_MIPMAP
	string Script= 
		"RenderColorTarget0=UseMipmapObjectTexture;"
			"RenderDepthStencilTarget=DepthBuffer;"
				"ClearSetColor=ClearColor;"
				"ClearSetDepth=ClearDepth;"
				"Clear=Color;"
				"Clear=Depth;"
			"Pass=CreateMipmap;"
	#ifdef USE_EDGE_TWEAK
		"RenderColorTarget0=;"
			"RenderDepthStencilTarget=;"
			"Pass=DrawEdge;"
	#endif
		;
#endif
 > {
#ifdef USE_MIPMAP
	pass CreateMipmap < string Script= "Draw=Buffer;"; > {
		AlphaBlendEnable = FALSE;
		ZEnable = FALSE;
		VertexShader = compile vs_3_0 VS_MipMapCreater();
		PixelShader  = compile ps_3_0 PS_MipMapCreater();
	}
#endif
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(true, true, true);
        PixelShader  = compile ps_3_0 Basic_PS(true, true, true);
    }
#ifdef USE_EDGE_TWEAK
    pass DrawEdge {
		CULLMODE = CW;
        VertexShader = compile vs_3_0 BasicEdge_VS(true, true, true);
        PixelShader  = compile ps_3_0 BasicEdge_PS(true, true, true);
    }
#endif
}
#endif
#ifdef USE_SELFSHADOW_MODE
///////////////////////////////////////////////////////////////////////////////////////////////
// セルフシャドウ用Z値プロット

struct VS_ZValuePlot_OUTPUT {
	float4 Pos : POSITION;			  // 射影変換座標
	float4 ShadowMapTex : TEXCOORD0;	// Zバッファテクスチャ
};

// 頂点シェーダ
VS_ZValuePlot_OUTPUT ZValuePlot_VS( float4 Pos : POSITION )
{
	VS_ZValuePlot_OUTPUT Out = (VS_ZValuePlot_OUTPUT)0;

	// ライトの目線によるワールドビュー射影変換をする
	Out.Pos = mul( Pos, LightWorldViewProjMatrix );

	// テクスチャ座標を頂点に合わせる
	Out.ShadowMapTex = Out.Pos;

	return Out;
}

// ピクセルシェーダ
float4 ZValuePlot_PS( float4 ShadowMapTex : TEXCOORD0 ) : COLOR
{
	// R色成分にZ値を記録する
	return float4(ShadowMapTex.z/ShadowMapTex.w,0,0,1);
}

// Z値プロット用テクニック
technique ZplotTec < string MMDPass = "zplot"; > {
#ifndef USE_ABSOLUTE_SHADOW_SYSTEM
	pass ZValuePlot {
		AlphaBlendEnable = FALSE;
		VertexShader = compile vs_2_0 ZValuePlot_VS();
		PixelShader  = compile ps_2_0 ZValuePlot_PS();
	}
#endif
}

///////////////////////////////////////////////////////////////////////////////////////////////
// オブジェクト描画（セルフシャドウON）

// シャドウバッファのサンプラ。"register(s0)"なのはMMDがs0を使っているから
sampler DefSampler : register(s0);

struct BufferShadow_OUTPUT {
	float4 Pos	  : POSITION;		// 射影変換座標
	float4 ZCalcTex : TEXCOORD0;	// Z値
	float2 Tex	  : TEXCOORD1;		// テクスチャ
	float3 Normal   : TEXCOORD2;	// 法線
	float3 Eye	  : TEXCOORD3;		// カメラとの相対位置
	float2 SpTex	: TEXCOORD4;	// スフィアマップテクスチャ座標
	float4 Color	: COLOR0;		// ディフューズ色
#ifdef USE_EXCELLENT_SHADOW_SYSTEM
	float4 ScreenTex : TEXCOORD6;   // スクリーン座標
#endif
	int idx : _INDEX;				// 頂点インデックス
};

// 頂点シェーダ
BufferShadow_OUTPUT BufferShadow_VS(float4 Pos : POSITION, float3 Normal : NORMAL, float2 Tex : TEXCOORD0, int idx: _INDEX, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon)
{
	BufferShadow_OUTPUT Out = (BufferShadow_OUTPUT)0;

	// カメラ視点のワールドビュー射影変換
	Out.Pos = mul( Pos, WorldViewProjMatrix );

	// カメラとの相対位置
	Out.Eye = CameraPosition - mul( Pos, WorldMatrix );
	// 頂点法線
	Out.Normal = normalize( mul( Normal, (float3x3)WorldMatrix ) );
	// ライト視点によるワールドビュー射影変換
	Out.ZCalcTex = mul( Pos, LightWorldViewProjMatrix );

	// ディフューズ色＋アンビエント色 計算
	Out.Color.rgb = EgColor.rgb;
	if ( !useToon ) {
		Out.Color.rgb += max(0,dot( Out.Normal, -LightDirection )) * DiffuseColor.rgb;
	}
    Out.Color.a = EgColor.a;
	Out.Color = saturate( Out.Color );

	// テクスチャ座標
	Out.Tex = Tex;

#ifdef USE_MATERIAL_SPHERE
	if ( useSphereMap ) {
		// スフィアマップテクスチャ座標
		float2 NormalWV = mul( Out.Normal, (float3x3)ViewMatrix );
		Out.SpTex.x = NormalWV.x * 0.5f + 0.5f;
		Out.SpTex.y = NormalWV.y * -0.5f + 0.5f;
	}
#endif

#ifdef USE_EXCELLENT_SHADOW_SYSTEM
	//スクリーン座標取得
	Out.ScreenTex = Out.Pos;
	
	//超遠景におけるちらつき防止
	Out.Pos.z -= max(0, (int)((CameraDistance1 - 6000) * 0.04));
#endif
	return Out;
}

float4 _ShaderMain(BufferShadow_OUTPUT IN, bool useTexture, bool useSphereMap, bool useToon)
{
	float3 N = normalize(IN.Normal);
	float3 V = normalize(IN.Eye);

#ifdef USE_NORMALMAP
	// ------------------------------------------------------------
	// 法線マップ処理
	// ------------------------------------------------------------
	// 法線マップによる法線補正
	float4 NormalColor = tex2D( NormalMapSamp, IN.Tex * NormalMapResolution) * 2;
	NormalColor = NormalColor.rgba;
	NormalColor.a = 1;
	float3x3 tangentFrame = compute_tangent_frame(N, V, IN.Tex);
	N = normalize(mul(NormalColor - 1.0f, tangentFrame));
#endif

	// ------------------------------------------------------------
	// シェーディング計算
	// ------------------------------------------------------------
	float d;
//#ifdef USE_ABSOLUTE_SHADOW_SYSTEM
//	d = dot(normalize(IN.Normal),-normalize(-Rot._21_22_23));
//#else
	d = dot(N,-LightDirection);
//#endif

	// テクスチャ座標に変換
	IN.ZCalcTex /= IN.ZCalcTex.w;
	float2 TransTexCoord = 0.5 + IN.ZCalcTex * float2(0.5, -0.5);

	// ------------------------------------------------------------
	// セルフシャドウ処理
	// ------------------------------------------------------------
	float compBak = d;
#ifdef USE_EXCELLENT_SHADOW_SYSTEM
	IN.ScreenTex.xyz /= IN.ScreenTex.w;
	float2 TransScreenTex;
	TransScreenTex.x = (1.0f + IN.ScreenTex.x) * 0.5f;
	TransScreenTex.y = (1.0f - IN.ScreenTex.y) * 0.5f;
	TransScreenTex += ES_ViewportOffset;
	float ShadowMapVal = tex2D(ScreenShadowMapProcessedSamp, TransScreenTex).r;
	d *= 1 - (1 - ShadowMapVal) * SelfShadowPower;
	float SSAOMapVal = 0;
	if(Exist_ExShadowSSAO){
		SSAOMapVal = tex2D(ExShadowSSAOMapSamp , TransScreenTex).r; //陰度取得
//		return float4(SSAOMapVal, 0, 0, 1);
	}
#else
	if( !any( saturate(TransTexCoord) != TransTexCoord ) ) {
#ifdef USE_ABSOLUTE_SHADOW_SYSTEM
		float comp = saturate(dot(IN.Normal,-LightDirVec)*Toon);
		////VSM法の実装
		float2 depth = GetZBufSample(TransTexCoord);
		depth.y += 0.00002;
		float sigma2 = depth.y - depth.x * depth.x;
		float comp2 = sigma2 / (sigma2 + IN.ZCalcTex.z - depth.x);
		comp2 = saturate(comp2) + (comp2 < 0);
		d *= min(comp, comp2);
#else
		float comp;
		float comp2;
		if(parthf) {
			// セルフシャドウ mode2
		#ifdef USE_SOFT_SHADOW
			float U = SoftShadowParam / SOFTSHADOW_RESOLUTION;
			float V = SoftShadowParam / SOFTSHADOW_RESOLUTION;
			comp2  = saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord + float2( U, 0)).r , 0.0f) * SKII2 * TransTexCoord.y - 0.3f);
			comp2 += saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord + float2(-U, 0)).r , 0.0f) * SKII2 * TransTexCoord.y - 0.3f);
			comp2 += saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord + float2( 0, V)).r , 0.0f) * SKII2 * TransTexCoord.y - 0.3f);
			comp2 += saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord + float2( 0,-V)).r , 0.0f) * SKII2 * TransTexCoord.y - 0.3f);
			comp2 += saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord + float2( U, V)).r , 0.0f) * SKII2 * TransTexCoord.y - 0.3f);
			comp2 += saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord + float2(-U, V)).r , 0.0f) * SKII2 * TransTexCoord.y - 0.3f);
			comp2 += saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord + float2(-U,-V)).r , 0.0f) * SKII2 * TransTexCoord.y - 0.3f);
			comp2 += saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord + float2( U,-V)).r , 0.0f) * SKII2 * TransTexCoord.y - 0.3f);
			comp = 1 - saturate(comp2 / 9) * SelfShadowPower;
		#else
			comp = 1 - saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord).r , 0.0f) * SKII2 * TransTexCoord.y - 0.3f) * SelfShadowPower;
		#endif
			compBak = comp;
		} else {
			// セルフシャドウ mode1
		#ifdef USE_SOFT_SHADOW
			float U = SoftShadowParam / SOFTSHADOW_RESOLUTION;
			float V = SoftShadowParam / SOFTSHADOW_RESOLUTION;
			comp2  = saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord				).r , 0.0f) * SKII1 - 0.3f);
			comp2 += saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord + float2( U, 0)).r , 0.0f) * SKII1 - 0.3f);
			comp2 += saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord + float2(-U, 0)).r , 0.0f) * SKII1 - 0.3f);
			comp2 += saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord + float2( 0, V)).r , 0.0f) * SKII1 - 0.3f);
			comp2 += saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord + float2( 0,-V)).r , 0.0f) * SKII1 - 0.3f);
			comp2 += saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord + float2( U, V)).r , 0.0f) * SKII1 - 0.3f);
			comp2 += saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord + float2(-U, V)).r , 0.0f) * SKII1 - 0.3f);
			comp2 += saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord + float2(-U,-V)).r , 0.0f) * SKII1 - 0.3f);
			comp2 += saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord + float2( U,-V)).r , 0.0f) * SKII1 - 0.3f);
			comp = 1 - saturate(comp2 / 9) * SelfShadowPower;
		#else
			comp = 1 - saturate(max(IN.ZCalcTex.z - tex2D(DefSampler, TransTexCoord).r , 0.0f) * SKII1 - 0.3f) * SelfShadowPower;
		#endif
		}
		d *= comp;
#endif
	}
#endif

	// ------------------------------------------------------------
	// ランバート計算
	// ------------------------------------------------------------
#ifdef USE_LAMBERT
	d = pow(d * LambertFactor + (1 - LambertFactor), 2);
#endif

	d = max(0, d);

	// ------------------------------------------------------------
	// フィルライト計算
	// ------------------------------------------------------------
#ifdef USE_FILL_LIGHT_TYPE1
	d += max(0, dot(N, V) * FillLight1Power);
#endif
#ifdef USE_FILL_LIGHT_TYPE2
	d += max(0, dot(normalize(IN.Normal * float3(-1,-1,1)), -LightDirection) * FillLight2Power);
#endif

	// ------------------------------------------------------------
	// リムライト計算
	// ------------------------------------------------------------
#ifdef USE_RIM_LIGHT
	float3 RimColor = (1 - max(0, pow(dot( IN.Normal, V), 2))) * RimLightPower;
	RimColor = pow(RimColor, RimLightThreshold);
	// リムライト適用
	d += RimColor.r;
#endif

	// ------------------------------------------------------------
	// セルフシャドウの適用
	// ------------------------------------------------------------
	float4 Color = IN.Color;
	float4 ShadowColor = float4(EgColor.rgb, Color.a);  // 影の色
	if ( useTexture ) {
		// テクスチャ適用
		float4 TexColor = tex2D( ObjTexSampler, IN.Tex );
#ifdef USE_MATERIAL_TEXTURE
		ShadowColor *= TexColor;
#else
		// シャドウテクスチャ適用
		ShadowColor *= tex2D( ShadowTextureSampler, IN.Tex );
#endif
		Color *= TexColor;
	}
#ifdef USE_MATERIAL_TEXTURE
	// トゥーンテクスチャ適用
	if (useToon) {
#ifdef USE_EXCELLENT_SHADOW_SYSTEM
		ShadowMapVal = min(saturate(dot(IN.Normal, -LightDirection) * Toon), ShadowMapVal);
		ShadowColor.rgb *= MaterialToon;
#endif
#ifdef USE_MATERIAL_TEXTURE
		ShadowColor.rgb *= MaterialToon * DefaultModeShadowColor;
#else
		ShadowColor.rgb *= MaterialToon;
#endif
	}
#endif

#if defined(USE_ABSOLUTE_SHADOW_SYSTEM)
	ShadowColor.rgb *= (1 - (1 - ShadowRate) * SelfShadowPower);
#elif defined(USE_EXCELLENT_SHADOW_SYSTEM)
    float4 ShadowColor2 = ShadowColor;
    ShadowColor2.rgb -= ((Color.rgb - ShadowColor2.rgb) + 0.3) * SSAOMapVal * 0.2;
    ShadowColor2.rgb = max(ShadowColor2.rgb, 0);//ShadowColor.rgb * 0.5);

    //日向部分のSSAO合成
    Color = lerp(Color, ShadowColor, saturate(SSAOMapVal * 0.4));
#endif
#ifdef USE_SHADOWCOLOR_SELFPOWER_MODE
	// 材質の自己乗算で影色を傾向付ける
	float3 tmpColor = saturate(Color.rgb - 0.01); // 1.0対策
#ifdef SELFPOWER_MODE_IGNORE_SHADOWLEVEL
	ShadowColor.rgb = pow(tmpColor, SelfPowerShadowStrength);
#else
	ShadowColor.rgb *= pow(tmpColor, SelfPowerShadowStrength);
#endif
#endif

	// ------------------------------------------------------------
	// スペキュラの適用
	// ------------------------------------------------------------
#ifdef USE_MATERIAL_SPECULAR
	// スペキュラ色計算
	float3 HalfVector = normalize( V + -LightDirection );
	#ifdef USE_EXSPECULAR
    float3 Specular = CalcSpecular(normalize(-LightDirection), N, V, EgColor)  * LightAmbient;
		#ifdef USE_FILL_LIGHT_TYPE1
    Specular += CalcSpecular(V, N, V, EgColor * FillLight1Power) * LightAmbient;
		#endif
		#ifdef USE_FILL_LIGHT_TYPE2
    Specular += CalcSpecular(normalize(-LightDirection * float3(-1,-1,1)), N, V, EgColor * FillLight2Power) * LightAmbient;
		#endif
		#ifdef USE_RIM_LIGHT
    Specular += CalcSpecular(1 - V, N, V, EgColor * RimLightPower) * LightAmbient;
		#endif
	Specular *= 0.1;
	#else
	float3 Specular = pow( max(0,dot( HalfVector, N )), SpcColor.a ) * SpcColor.rgb;
	#endif

	#ifdef USE_SPECULAR_CHEET
		Specular *= SpecularBoost;
	#endif
	Color.rgb += Specular;
	ShadowColor.rgb += Specular;
	d += max(max(Specular.r, Specular.g), Specular.b);
#endif

	// ------------------------------------------------------------
	// スフィアマップ適用
	// ------------------------------------------------------------
#ifdef USE_MATERIAL_SPHERE
	if ( useSphereMap ) {
		float4 TexColor = tex2D(ObjSphareSampler,IN.SpTex);
	#ifdef USE_SPHERE_CHEET
		TexColor *= SphereBoost;
	#endif
		if(spadd) {
			Color.rgb += TexColor.rgb;
			ShadowColor.rgb += TexColor.rgb;
			d += max(max(TexColor.r, TexColor.g),TexColor.b);
		} else {
			Color.rgb *= TexColor.rgb;
			ShadowColor.rgb *= TexColor.rgb;
			d *= max(max(TexColor.r, TexColor.g),TexColor.b);
		}
	}
#endif

	// ------------------------------------------------------------
	// シェードマップの適用
	// ------------------------------------------------------------
	float4 Threshold = tex2D( ThresholdTextureSampler, float2(saturate(d), 0));

	// ------------------------------------------------------------
	// シェードマップのα値で明るさ強調
	// ------------------------------------------------------------
#ifdef USE_HIGHLIGHT_TEXTURE
	float4 HighlightColor = tex2D(HighlightTextureSampler, IN.Tex);
	Color.rgb = lerp(HighlightColor.rgb, Color.rgb, saturate(Threshold.a));
	#ifdef USE_HIGHLIGHT_CHEET
	HighlightColor *= (1 + pow((1 - Threshold.a), 1 / HighlightPower));
	Color.rgb = lerp(HighlightColor.rgb , Color.rgb, Threshold.a);
	#endif
#else
	#ifdef USE_HIGHLIGHT_CHEET
	float3 HighlightColor = (1 + pow((1 - Threshold.a), 1 / HighlightPower));
	Color.rgb = lerp(Color.rgb * HighlightColor, Color.rgb, Threshold.a);
	#endif
#endif

	// ------------------------------------------------------------
	// 明暗のブレンド
	// ------------------------------------------------------------
	Color.rgb = lerp(ShadowColor.rgb, Color.rgb, Threshold);

	return Color;
}

// ピクセルシェーダ
float4 BufferShadow_PS(BufferShadow_OUTPUT IN, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon) : COLOR
{
	float4 Color = _ShaderMain(IN, useTexture, useSphereMap, useToon);
#ifdef HIGHLIGHT_ANTI_AUTOLUMINOUS
	return saturate(Color);
#else
	return Color;
#endif
}

#ifdef USE_EDGE_TWEAK
// 頂点シェーダ
BufferShadow_OUTPUT Edge_VS(float4 Pos : POSITION, float3 Normal : NORMAL, float2 Tex : TEXCOORD0, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon)
{
	BufferShadow_OUTPUT Out = (BufferShadow_OUTPUT)0;

	// カメラとの相対位置
	Out.Eye = CameraPosition - mul( Pos, WorldMatrix );

	// カメラ視点のワールドビュー射影変換
	Out.Pos = mul( Pos, WorldViewProjMatrix );

	// 頂点法線
	Out.Normal = normalize( mul( Normal, (float3x3)WorldMatrix ) );

	// 法線方向にちょっとだけ膨らます
	#ifdef TEXTURE_EDGE_SCALE
	EdgeTickness *= 1 + tex2Dlod(EdgeScaleSampler, float4(Tex, 0, 0)).r * EdgeScale;
	#endif
	#ifdef USE_EXCELLENT_SHADOW_SYSTEM
	if(Exist_ExShadowSSAO) {
		// AOエッジ処理
		float2 TransScreenTex;
		TransScreenTex.x = (1.0f + Out.Pos.x / Out.Pos.w) * 0.5f;
		TransScreenTex.y = (1.0f - Out.Pos.y / Out.Pos.w) * 0.5f;
		TransScreenTex += ES_ViewportOffset;
		float SSAOMapVal = tex2Dlod(ExShadowSSAOMapSamp , float4(TransScreenTex, 0, 0)).r; //陰度取得
		EdgeTickness *= 1 + SSAOMapVal * EdgeScale;
	}
	#endif
	float4 tmpNormal = mul(Normal, WorldViewProjMatrix);
	tmpNormal.zw = 0;
	tmpNormal = normalize(tmpNormal) * EdgeTickness;
	Out.Pos.xy += tmpNormal * Out.Pos.w;

	// ライト視点によるワールドビュー射影変換
	Out.ZCalcTex = mul( Pos, LightWorldViewProjMatrix );

	// ディフューズ色＋アンビエント色 計算
	Out.Color.rgb = EgColor.rgb;
	if ( !useToon ) {
		Out.Color.rgb += max(0,dot( Out.Normal, -LightDirection )) * DiffuseColor.rgb;
	}
	Out.Color.a = EgColor.a;
	Out.Color = saturate( Out.Color );

	// テクスチャ座標
	Out.Tex = Tex;

#ifdef USE_MATERIAL_SPHERE
	if ( useSphereMap ) {
		// スフィアマップテクスチャ座標
		float2 NormalWV = mul( Out.Normal, (float3x3)ViewMatrix );
		Out.SpTex.x = NormalWV.x * 0.5f + 0.5f;
		Out.SpTex.y = NormalWV.y * -0.5f + 0.5f;
	}
#endif

#ifdef USE_EXCELLENT_SHADOW_SYSTEM
	//スクリーン座標取得
	Out.ScreenTex = Out.Pos;
	
	//超遠景におけるちらつき防止
	Out.Pos.z -= max(0, (int)((CameraDistance1 - 6000) * 0.04));
#endif
	return Out;
}

// ピクセルシェーダ
float4 Edge_PS(BufferShadow_OUTPUT IN, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon) : COLOR
{
	#ifdef TEXTURE_EDGE
	float4 Color = tex2D(EdgeSampler, IN.Tex);
	#else
	float4 Color = saturate(_ShaderMain(IN, useTexture, useSphereMap, useToon));
	Color.rgb = pow(Color.rgb, EdgePower) * EdgeDarkness;
	#endif
	return Color;
}
#endif

// オブジェクト描画用テクニック（アクセサリ用）
technique MainTecBS0  < string MMDPass = "object_ss"; bool UseTexture = false; bool UseSphereMap = false; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(false, false, false);
        PixelShader  = compile ps_3_0 BufferShadow_PS(false, false, false);
    }
#ifdef USE_EDGE_TWEAK
    pass DrawEdge {
		CULLMODE = CW;
    	VertexShader = compile vs_3_0 Edge_VS(false, false, false);
        PixelShader  = compile ps_3_0 Edge_PS(false, false, false);
    }
#endif
}

technique MainTecBS1  < string MMDPass = "object_ss"; bool UseTexture = true; bool UseSphereMap = false; bool UseToon = false; 
#ifdef USE_MIPMAP
	string Script= 
		"RenderColorTarget0=UseMipmapObjectTexture;"
			"RenderDepthStencilTarget=DepthBuffer;"
				"ClearSetColor=ClearColor;"
				"ClearSetDepth=ClearDepth;"
				"Clear=Color;"
				"Clear=Depth;"
			"Pass=CreateMipmap;"
		"RenderColorTarget0=;"
			"RenderDepthStencilTarget=;"
			"Pass=DrawObject;"
	#ifdef USE_EDGE_TWEAK
		"RenderColorTarget0=;"
			"RenderDepthStencilTarget=;"
			"Pass=DrawEdge;"
	#endif
		;
#endif
 > {
#ifdef USE_MIPMAP
	pass CreateMipmap < string Script= "Draw=Buffer;"; > {
		AlphaBlendEnable = FALSE;
		ZEnable = FALSE;
		VertexShader = compile vs_2_0 VS_MipMapCreater();
		PixelShader  = compile ps_2_0 PS_MipMapCreater();
	}
#endif
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(true, false, false);
        PixelShader  = compile ps_3_0 BufferShadow_PS(true, false, false);
    }
#ifdef USE_EDGE_TWEAK
    pass DrawEdge {
		CULLMODE = CW;
        VertexShader = compile vs_3_0 Edge_VS(true, false, false);
        PixelShader  = compile ps_3_0 Edge_PS(true, false, false);
    }
#endif
}

technique MainTecBS2  < string MMDPass = "object_ss"; bool UseTexture = false; bool UseSphereMap = true; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(false, true, false);
        PixelShader  = compile ps_3_0 BufferShadow_PS(false, true, false);
    }
#ifdef USE_EDGE_TWEAK
    pass DrawEdge {
		CULLMODE = CW;
    	VertexShader = compile vs_3_0 Edge_VS(false, true, false);
        PixelShader  = compile ps_3_0 Edge_PS(false, true, false);
    }
#endif
}

technique MainTecBS3  < string MMDPass = "object_ss"; bool UseTexture = true; bool UseSphereMap = true; bool UseToon = false; 
#ifdef USE_MIPMAP
	string Script= 
		"RenderColorTarget0=UseMipmapObjectTexture;"
			"RenderDepthStencilTarget=DepthBuffer;"
				"ClearSetColor=ClearColor;"
				"ClearSetDepth=ClearDepth;"
				"Clear=Color;"
				"Clear=Depth;"
			"Pass=CreateMipmap;"
		"RenderColorTarget0=;"
			"RenderDepthStencilTarget=;"
			"Pass=DrawObject;"
	#ifdef USE_EDGE_TWEAK
		"RenderColorTarget0=;"
			"RenderDepthStencilTarget=;"
			"Pass=DrawEdge;"
	#endif
		;
#endif
 > {
#ifdef USE_MIPMAP
	pass CreateMipmap < string Script= "Draw=Buffer;"; > {
		AlphaBlendEnable = FALSE;
		ZEnable = FALSE;
		VertexShader = compile vs_2_0 VS_MipMapCreater();
		PixelShader  = compile ps_2_0 PS_MipMapCreater();
	}
#endif
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(true, true, false);
        PixelShader  = compile ps_3_0 BufferShadow_PS(true, true, false);
    }
#ifdef USE_EDGE_TWEAK
    pass DrawEdge {
		CULLMODE = CW;
        VertexShader = compile vs_3_0 Edge_VS(true, true, false);
        PixelShader  = compile ps_3_0 Edge_PS(true, true, false);
    }
#endif
}

// オブジェクト描画用テクニック（PMDモデル用）
technique MainTecBS4  < string MMDPass = "object_ss"; bool UseTexture = false; bool UseSphereMap = false; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(false, false, true);
        PixelShader  = compile ps_3_0 BufferShadow_PS(false, false, true);
    }
#ifdef USE_EDGE_TWEAK
    pass DrawEdge {
		CULLMODE = CW;
    	VertexShader = compile vs_3_0 Edge_VS(false, false, true);
        PixelShader  = compile ps_3_0 Edge_PS(false, false, true);
    }
#endif
}

technique MainTecBS5  < string MMDPass = "object_ss"; bool UseTexture = true; bool UseSphereMap = false; bool UseToon = true;
#ifdef USE_MIPMAP
	string Script= 
		"RenderColorTarget0=UseMipmapObjectTexture;"
			"RenderDepthStencilTarget=DepthBuffer;"
				"ClearSetColor=ClearColor;"
				"ClearSetDepth=ClearDepth;"
				"Clear=Color;"
				"Clear=Depth;"
			"Pass=CreateMipmap;"
		"RenderColorTarget0=;"
			"RenderDepthStencilTarget=;"
			"Pass=DrawObject;"
	#ifdef USE_EDGE_TWEAK
		"RenderColorTarget0=;"
			"RenderDepthStencilTarget=;"
			"Pass=DrawEdge;"
	#endif
		;
#endif
 > {
#ifdef USE_MIPMAP
	pass CreateMipmap < string Script= "Draw=Buffer;"; > {
		AlphaBlendEnable = FALSE;
		ZEnable = FALSE;
		VertexShader = compile vs_2_0 VS_MipMapCreater();
		PixelShader  = compile ps_2_0 PS_MipMapCreater();
	}
#endif
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(true, false, true);
        PixelShader  = compile ps_3_0 BufferShadow_PS(true, false, true);
    }
#ifdef USE_EDGE_TWEAK
    pass DrawEdge {
		CULLMODE = CW;
        VertexShader = compile vs_3_0 Edge_VS(true, false, true);
        PixelShader  = compile ps_3_0 Edge_PS(true, false, true);
    }
#endif
}

technique MainTecBS6  < string MMDPass = "object_ss"; bool UseTexture = false; bool UseSphereMap = true; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(false, true, true);
        PixelShader  = compile ps_3_0 BufferShadow_PS(false, true, true);
    }
#ifdef USE_EDGE_TWEAK
    pass DrawEdge {
		CULLMODE = CW;
    	VertexShader = compile vs_3_0 Edge_VS(false, true, true);
        PixelShader  = compile ps_3_0 Edge_PS(false, true, true);
    }
#endif
}

technique MainTecBS7  < string MMDPass = "object_ss"; bool UseTexture = true; bool UseSphereMap = true; bool UseToon = true;
#ifdef USE_MIPMAP
	string Script= 
		"RenderColorTarget0=UseMipmapObjectTexture;"
			"RenderDepthStencilTarget=DepthBuffer;"
				"ClearSetColor=ClearColor;"
				"ClearSetDepth=ClearDepth;"
				"Clear=Color;"
				"Clear=Depth;"
			"Pass=CreateMipmap;"
		"RenderColorTarget0=;"
			"RenderDepthStencilTarget=;"
			"Pass=DrawObject;"
	#ifdef USE_EDGE_TWEAK
		"RenderColorTarget0=;"
			"RenderDepthStencilTarget=;"
			"Pass=DrawEdge;"
	#endif
		;
#endif
 > {
#ifdef USE_MIPMAP
	pass CreateMipmap < string Script= "Draw=Buffer;"; > {
		AlphaBlendEnable = FALSE;
		ZEnable = FALSE;
		VertexShader = compile vs_2_0 VS_MipMapCreater();
		PixelShader  = compile ps_2_0 PS_MipMapCreater();
	}
#endif
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(true, true, true);
        PixelShader  = compile ps_3_0 BufferShadow_PS(true, true, true);
    }
#ifdef USE_EDGE_TWEAK
    pass DrawEdge {
		CULLMODE = CW;
        VertexShader = compile vs_3_0 Edge_VS(true, true, true);
        PixelShader  = compile ps_3_0 Edge_PS(true, true, true);
    }
#endif
}
#endif
///////////////////////////////////////////////////////////////////////////////////////////////
